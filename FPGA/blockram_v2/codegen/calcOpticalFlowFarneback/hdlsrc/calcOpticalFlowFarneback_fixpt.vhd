-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\USER\Desktop\Farneback_blockRAM\blockram_v2\codegen\calcOpticalFlowFarneback\hdlsrc\calcOpticalFlowFarneback_fixpt.vhd
-- Created: 2020-06-04 16:22:57
-- 
-- Generated by MATLAB 9.7, MATLAB Coder 4.3 and HDL Coder 3.15
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 0.25
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- outdata                       ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: calcOpticalFlowFarneback_fixpt
-- Source Path: calcOpticalFlowFarneback_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.calcOpticalFlowFarneback_fixpt_pkg.ALL;

ENTITY calcOpticalFlowFarneback_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        indata                            :   IN    std_logic_vector(7 DOWNTO 0);  -- ufix8
        ce_out                            :   OUT   std_logic;
        outdata                           :   OUT   std_logic_vector(13 DOWNTO 0)  -- ufix14_En7
        );
END calcOpticalFlowFarneback_fixpt;


ARCHITECTURE rtl OF calcOpticalFlowFarneback_fixpt IS

  -- Component Declarations
  COMPONENT calcOpticalFlowFarneback_fixpt_enb_bypass
    PORT( clk_1                           :   IN    std_logic;
          reset_1                         :   IN    std_logic;
          clk_enable_1                    :   IN    std_logic;
          clk_enable_2                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT calcOpticalFlowFarneback_fixpt_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_4_0                       :   OUT   std_logic;
          enb_1_4_1                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : calcOpticalFlowFarneback_fixpt_enb_bypass
    USE ENTITY work.calcOpticalFlowFarneback_fixpt_enb_bypass(rtl);

  FOR ALL : calcOpticalFlowFarneback_fixpt_tc
    USE ENTITY work.calcOpticalFlowFarneback_fixpt_tc(rtl);

  FOR ALL : SimpleDualPortRAM_generic
    USE ENTITY work.SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL enb_1_4_0                        : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_4_1                        : std_logic;
  SIGNAL clk_enable_1                     : std_logic;
  SIGNAL counterSig                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL indata_unsigned                  : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL delayMatch_reg                   : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL indata_1                         : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL delayMatch_reg_1                 : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL tmp_1                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_2                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL delayMatch_reg_2                 : vector_of_unsigned8(0 TO 2);  -- ufix8 [3]
  SIGNAL tmp_3                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL wr_data                          : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL wr_data_overclock4               : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL ratechange_splitcomp_out0        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out1        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out2        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out3        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ctr                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ctr_1                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_4                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_5                            : std_logic;
  SIGNAL tmp_6                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_7                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL p8tmp_add_temp                   : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL p8tmp_sub_cast                   : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_8                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL p11tmp_add_temp                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL p11tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_9                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL p14tmp_add_temp                  : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL p14tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL delayMatch_reg_3                 : vector_of_signed32(0 TO 2);  -- sfix32 [3]
  SIGNAL tmp_10                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig              : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL delayMatch_reg_4                 : vector_of_signed32(0 TO 2);  -- sfix32 [3]
  SIGNAL tmp_11                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig_1            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL delayMatch_reg_5                 : vector_of_signed32(0 TO 2);  -- sfix32 [3]
  SIGNAL tmp_12                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig_2            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wr_addr                          : vector_of_unsigned10(0 TO 3);  -- ufix10 [4]
  SIGNAL wr_addr_overclock4               : vector_of_unsigned10(0 TO 3);  -- ufix10 [4]
  SIGNAL ratechange_splitcomp_out0_1      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ratechange_splitcomp_out1_1      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ratechange_splitcomp_out2_1      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ratechange_splitcomp_out3_1      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wr_data_1                        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL wr_addr_1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL row_RAM_ram_wr_en_k_0_sig        : std_logic;
  SIGNAL row_RAM_ram_wr_en_k_1_sig        : std_logic;
  SIGNAL row_RAM_ram_wr_en_k_2_sig        : std_logic;
  SIGNAL row_RAM_ram_wr_en_k_3_sig        : std_logic;
  SIGNAL row_RAM_ram_wren_match_out_1     : std_logic;
  SIGNAL row_RAM_ram_wren_match_1_reg     : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL row_RAM_ram_wren_match_out_2     : std_logic;
  SIGNAL row_RAM_ram_wren_match_out_3     : std_logic;
  SIGNAL row_RAM_ram_wren_match_out_4     : std_logic;
  SIGNAL row_RAM_ram_wren_match_1_reg_1   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL row_RAM_ram_wren_match_1_reg_2   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL row_RAM_ram_wren_match_1_reg_3   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL row_RAM_ram_wr_en_sig            : std_logic_vector(0 TO 3);  -- boolean [4]
  SIGNAL row_RAM_ram_wr_en_sig_overclock4 : std_logic_vector(0 TO 3);  -- boolean [4]
  SIGNAL ratechange_splitcomp_out0_2      : std_logic;
  SIGNAL ratechange_splitcomp_out1_2      : std_logic;
  SIGNAL ratechange_splitcomp_out2_2      : std_logic;
  SIGNAL ratechange_splitcomp_out3_2      : std_logic;
  SIGNAL tmp_13                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL p16tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL delayMatch_reg_6                 : vector_of_signed32(0 TO 2);  -- sfix32 [3]
  SIGNAL tmp_14                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig_3            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rd_addr                          : vector_of_unsigned10(0 TO 3);  -- ufix10 [4]
  SIGNAL rd_addr_overclock4               : vector_of_unsigned10(0 TO 3);  -- ufix10 [4]
  SIGNAL ratechange_splitcomp_out0_3      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ratechange_splitcomp_out1_3      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ratechange_splitcomp_out2_3      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ratechange_splitcomp_out3_3      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL row_RAM_ram_wr_en_sig_1          : std_logic;
  SIGNAL rd_addr_1                        : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rd_data                          : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL rd_data_unsigned                 : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL sel                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL sel_1                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL row_RAM_ram_demux_yreg           : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL row_RAM_ram_demux_yreg_next      : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL row_RAM_ram_demux_ctr1           : signed(31 DOWNTO 0);  -- int32
  SIGNAL row_RAM_ram_demux_ytmp           : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL row_RAM_ram_demux_add_cast       : signed(31 DOWNTO 0);  -- int32
  SIGNAL rd_data_overclock4               : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL rd_data_downsample4_bypass_reg   : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL rd_data_1                        : vector_of_unsigned8(0 TO 3);  -- ufix8 [4]
  SIGNAL row_RAM                          : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL outdata_tmp                      : unsigned(13 DOWNTO 0);  -- ufix14_En7
  SIGNAL p21outdata_mul_temp              : unsigned(21 DOWNTO 0);  -- ufix22_En15

BEGIN
  u_calcOpticalFlowFarneback_fixpt_enb_bypass : calcOpticalFlowFarneback_fixpt_enb_bypass
    PORT MAP( clk_1 => clk,
              reset_1 => reset,
              clk_enable_1 => clk_enable,
              clk_enable_2 => clk_enable_1
              );

  u_calcOpticalFlowFarneback_fixpt_tc : calcOpticalFlowFarneback_fixpt_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable_1,
              enb => enb,
              enb_1_4_0 => enb_1_4_0,
              enb_1_4_1 => enb_1_4_1
              );

  u_row_RAM_ram_generic : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 8
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wr_data_1),
              wr_addr => std_logic_vector(wr_addr_1),
              wr_en => row_RAM_ram_wr_en_sig_1,
              rd_addr => std_logic_vector(rd_addr_1),
              rd_dout => rd_data
              );

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3
  ctr_0_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      counterSig <= to_unsigned(16#0#, 2);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        counterSig <= counterSig + to_unsigned(16#1#, 2);
      END IF;
    END IF;
  END PROCESS ctr_0_3_process;


  indata_unsigned <= unsigned(indata);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg(0) <= indata_unsigned;
        delayMatch_reg(1 TO 2) <= delayMatch_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  indata_1 <= delayMatch_reg(2);

  tmp <= to_unsigned(16#00#, 8);

  delayMatch_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_1 <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg_1(0) <= tmp;
        delayMatch_reg_1(1 TO 2) <= delayMatch_reg_1(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_1_process;

  tmp_1 <= delayMatch_reg_1(2);

  tmp_2 <= to_unsigned(16#00#, 8);

  delayMatch_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_2 <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg_2(0) <= tmp_2;
        delayMatch_reg_2(1 TO 2) <= delayMatch_reg_2(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_2_process;

  tmp_3 <= delayMatch_reg_2(2);

  wr_data(0) <= indata_1;
  wr_data(1) <= tmp_1;
  wr_data(2) <= tmp_3;
  wr_data(3) <= indata_1;

  wr_data_overclock4 <= wr_data;

  ratechange_splitcomp_out0 <= wr_data_overclock4(0);

  ratechange_splitcomp_out1 <= wr_data_overclock4(1);

  ratechange_splitcomp_out2 <= wr_data_overclock4(2);

  ratechange_splitcomp_out3 <= wr_data_overclock4(3);

  -- HDL code generation from MATLAB function: calcOpticalFlowFarneback_fixpt_trueregionp2
  ctr <= to_unsigned(16#01#, 8);

  -- HDL code generation from MATLAB function: calcOpticalFlowFarneback_fixpt_falseregionp2
  tmp_4 <= ctr_1 + to_unsigned(16#01#, 8);

  
  tmp_5 <= '1' WHEN ctr_1 = to_unsigned(16#C8#, 8) ELSE
      '0';

  
  tmp_6 <= tmp_4 WHEN tmp_5 = '0' ELSE
      ctr;

  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  --                                                                          %
  -- 
  --           Generated by MATLAB 9.7 and Fixed-Point Designer 6.4           %
  -- 
  --                                                                          %
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  -------------------------------------------- Parameter Setting
  -- 
  --------------------------------------------
  -- 
  --------------------------------------------
  -- 
  ---------------------- Initial blockram 
  -- 
  ---------------------- write BRAM
  -- 
  ---------------------- read
  -- 
  -- HDL code generation from MATLAB function: calcOpticalFlowFarneback_fixpt
  -- 
  ---------------------- calculation
  -- 
  ---------------------- counter
  ctr_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ctr_1 <= to_unsigned(16#01#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        ctr_1 <= tmp_6;
      END IF;
    END IF;
  END PROCESS ctr_reg_process;


  p8tmp_add_temp <= resize(ctr_1 * to_unsigned(16#3#, 2), 11) + to_unsigned(16#019#, 11);
  p8tmp_sub_cast <= signed(resize(p8tmp_add_temp, 32));
  tmp_7 <= p8tmp_sub_cast - 1;

  p11tmp_add_temp <= resize(ctr_1 * to_unsigned(16#3#, 2), 11) + to_unsigned(16#01A#, 11);
  p11tmp_sub_cast <= signed(resize(p11tmp_add_temp, 32));
  tmp_8 <= p11tmp_sub_cast - 1;

  p14tmp_add_temp <= resize(ctr_1 * to_unsigned(16#3#, 2), 11) + to_unsigned(16#01B#, 11);
  p14tmp_sub_cast <= signed(resize(p14tmp_add_temp, 32));
  tmp_9 <= p14tmp_sub_cast - 1;

  delayMatch_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_3 <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg_3(0) <= tmp_7;
        delayMatch_reg_3(1 TO 2) <= delayMatch_reg_3(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_3_process;

  tmp_10 <= delayMatch_reg_3(2);

  indexLogic_fixptsig <= unsigned(tmp_10(9 DOWNTO 0));

  delayMatch_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_4 <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg_4(0) <= tmp_8;
        delayMatch_reg_4(1 TO 2) <= delayMatch_reg_4(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_4_process;

  tmp_11 <= delayMatch_reg_4(2);

  indexLogic_fixptsig_1 <= unsigned(tmp_11(9 DOWNTO 0));

  delayMatch_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_5 <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg_5(0) <= tmp_9;
        delayMatch_reg_5(1 TO 2) <= delayMatch_reg_5(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_5_process;

  tmp_12 <= delayMatch_reg_5(2);

  indexLogic_fixptsig_2 <= unsigned(tmp_12(9 DOWNTO 0));

  wr_addr(0) <= indexLogic_fixptsig;
  wr_addr(1) <= indexLogic_fixptsig_1;
  wr_addr(2) <= indexLogic_fixptsig_2;
  wr_addr(3) <= indexLogic_fixptsig;

  wr_addr_overclock4 <= wr_addr;

  ratechange_splitcomp_out0_1 <= wr_addr_overclock4(0);

  ratechange_splitcomp_out1_1 <= wr_addr_overclock4(1);

  ratechange_splitcomp_out2_1 <= wr_addr_overclock4(2);

  ratechange_splitcomp_out3_1 <= wr_addr_overclock4(3);

  
  wr_data_1 <= ratechange_splitcomp_out0 WHEN counterSig = to_unsigned(16#0#, 2) ELSE
      ratechange_splitcomp_out1 WHEN counterSig = to_unsigned(16#1#, 2) ELSE
      ratechange_splitcomp_out2 WHEN counterSig = to_unsigned(16#2#, 2) ELSE
      ratechange_splitcomp_out3;

  
  wr_addr_1 <= ratechange_splitcomp_out0_1 WHEN counterSig = to_unsigned(16#0#, 2) ELSE
      ratechange_splitcomp_out1_1 WHEN counterSig = to_unsigned(16#1#, 2) ELSE
      ratechange_splitcomp_out2_1 WHEN counterSig = to_unsigned(16#2#, 2) ELSE
      ratechange_splitcomp_out3_1;

  row_RAM_ram_wr_en_k_0_sig <= '1';

  row_RAM_ram_wren_match_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      row_RAM_ram_wren_match_1_reg <= (OTHERS => '0');
      row_RAM_ram_wren_match_1_reg_1 <= (OTHERS => '0');
      row_RAM_ram_wren_match_1_reg_2 <= (OTHERS => '0');
      row_RAM_ram_wren_match_1_reg_3 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        row_RAM_ram_wren_match_1_reg(0) <= row_RAM_ram_wr_en_k_0_sig;
        row_RAM_ram_wren_match_1_reg(1 TO 2) <= row_RAM_ram_wren_match_1_reg(0 TO 1);
        row_RAM_ram_wren_match_1_reg_1(0) <= row_RAM_ram_wr_en_k_1_sig;
        row_RAM_ram_wren_match_1_reg_1(1 TO 2) <= row_RAM_ram_wren_match_1_reg_1(0 TO 1);
        row_RAM_ram_wren_match_1_reg_2(0) <= row_RAM_ram_wr_en_k_2_sig;
        row_RAM_ram_wren_match_1_reg_2(1 TO 2) <= row_RAM_ram_wren_match_1_reg_2(0 TO 1);
        row_RAM_ram_wren_match_1_reg_3(0) <= row_RAM_ram_wr_en_k_3_sig;
        row_RAM_ram_wren_match_1_reg_3(1 TO 2) <= row_RAM_ram_wren_match_1_reg_3(0 TO 1);
      END IF;
    END IF;
  END PROCESS row_RAM_ram_wren_match_1_process;

  row_RAM_ram_wren_match_out_1 <= row_RAM_ram_wren_match_1_reg(2);
  row_RAM_ram_wren_match_out_2 <= row_RAM_ram_wren_match_1_reg_1(2);
  row_RAM_ram_wren_match_out_3 <= row_RAM_ram_wren_match_1_reg_2(2);
  row_RAM_ram_wren_match_out_4 <= row_RAM_ram_wren_match_1_reg_3(2);

  row_RAM_ram_wr_en_k_1_sig <= '1';

  row_RAM_ram_wr_en_k_2_sig <= '1';

  row_RAM_ram_wr_en_k_3_sig <= '0';

  row_RAM_ram_wr_en_sig(0) <= row_RAM_ram_wren_match_out_1;
  row_RAM_ram_wr_en_sig(1) <= row_RAM_ram_wren_match_out_2;
  row_RAM_ram_wr_en_sig(2) <= row_RAM_ram_wren_match_out_3;
  row_RAM_ram_wr_en_sig(3) <= row_RAM_ram_wren_match_out_4;

  row_RAM_ram_wr_en_sig_overclock4 <= row_RAM_ram_wr_en_sig;

  ratechange_splitcomp_out0_2 <= row_RAM_ram_wr_en_sig_overclock4(0);

  ratechange_splitcomp_out1_2 <= row_RAM_ram_wr_en_sig_overclock4(1);

  ratechange_splitcomp_out2_2 <= row_RAM_ram_wr_en_sig_overclock4(2);

  ratechange_splitcomp_out3_2 <= row_RAM_ram_wr_en_sig_overclock4(3);

  p16tmp_sub_cast <= signed(resize(ctr_1, 32));
  tmp_13 <= p16tmp_sub_cast - 1;

  delayMatch_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_6 <= (OTHERS => to_signed(0, 32));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_0 = '1' THEN
        delayMatch_reg_6(0) <= tmp_13;
        delayMatch_reg_6(1 TO 2) <= delayMatch_reg_6(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_6_process;

  tmp_14 <= delayMatch_reg_6(2);

  indexLogic_fixptsig_3 <= unsigned(tmp_14(9 DOWNTO 0));

  rd_addr(0) <= indexLogic_fixptsig_3;
  rd_addr(1) <= indexLogic_fixptsig_3;
  rd_addr(2) <= indexLogic_fixptsig_3;
  rd_addr(3) <= indexLogic_fixptsig_3;

  rd_addr_overclock4 <= rd_addr;

  ratechange_splitcomp_out0_3 <= rd_addr_overclock4(0);

  ratechange_splitcomp_out1_3 <= rd_addr_overclock4(1);

  ratechange_splitcomp_out2_3 <= rd_addr_overclock4(2);

  ratechange_splitcomp_out3_3 <= rd_addr_overclock4(3);

  
  row_RAM_ram_wr_en_sig_1 <= ratechange_splitcomp_out0_2 WHEN counterSig = to_unsigned(16#0#, 2) ELSE
      ratechange_splitcomp_out1_2 WHEN counterSig = to_unsigned(16#1#, 2) ELSE
      ratechange_splitcomp_out2_2 WHEN counterSig = to_unsigned(16#2#, 2) ELSE
      ratechange_splitcomp_out3_2;

  
  rd_addr_1 <= ratechange_splitcomp_out0_3 WHEN counterSig = to_unsigned(16#0#, 2) ELSE
      ratechange_splitcomp_out1_3 WHEN counterSig = to_unsigned(16#1#, 2) ELSE
      ratechange_splitcomp_out2_3 WHEN counterSig = to_unsigned(16#2#, 2) ELSE
      ratechange_splitcomp_out3_3;

  rd_data_unsigned <= unsigned(rd_data);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3
  c_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sel <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF sel >= to_unsigned(16#03#, 8) THEN 
          sel <= to_unsigned(16#00#, 8);
        ELSE 
          sel <= sel + to_unsigned(16#01#, 8);
        END IF;
      END IF;
    END IF;
  END PROCESS c_process;


  delayMatch_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sel_1 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sel_1 <= sel;
      END IF;
    END IF;
  END PROCESS delayMatch_7_process;


  row_RAM_ram_demux_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      row_RAM_ram_demux_yreg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        row_RAM_ram_demux_yreg <= row_RAM_ram_demux_yreg_next;
      END IF;
    END IF;
  END PROCESS row_RAM_ram_demux_process;

  row_RAM_ram_demux_add_cast <= signed(resize(sel_1, 32));
  row_RAM_ram_demux_ctr1 <= row_RAM_ram_demux_add_cast + 1;
  
  row_RAM_ram_demux_ytmp(0) <= rd_data_unsigned WHEN row_RAM_ram_demux_ctr1 = to_signed(16#00000001#, 32) ELSE
      row_RAM_ram_demux_yreg(0);
  
  row_RAM_ram_demux_ytmp(1) <= rd_data_unsigned WHEN row_RAM_ram_demux_ctr1 = to_signed(16#00000002#, 32) ELSE
      row_RAM_ram_demux_yreg(1);
  
  row_RAM_ram_demux_ytmp(2) <= rd_data_unsigned WHEN row_RAM_ram_demux_ctr1 = to_signed(16#00000003#, 32) ELSE
      row_RAM_ram_demux_yreg(2);
  
  row_RAM_ram_demux_ytmp(3) <= rd_data_unsigned WHEN row_RAM_ram_demux_ctr1 = to_signed(16#00000004#, 32) ELSE
      row_RAM_ram_demux_yreg(3);
  row_RAM_ram_demux_yreg_next(0) <= row_RAM_ram_demux_ytmp(0);
  rd_data_overclock4(0) <= row_RAM_ram_demux_ytmp(0);
  row_RAM_ram_demux_yreg_next(1) <= row_RAM_ram_demux_ytmp(1);
  rd_data_overclock4(1) <= row_RAM_ram_demux_ytmp(1);
  row_RAM_ram_demux_yreg_next(2) <= row_RAM_ram_demux_ytmp(2);
  rd_data_overclock4(2) <= row_RAM_ram_demux_ytmp(2);
  row_RAM_ram_demux_yreg_next(3) <= row_RAM_ram_demux_ytmp(3);
  rd_data_overclock4(3) <= row_RAM_ram_demux_ytmp(3);

  rd_data_downsample4_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_data_downsample4_bypass_reg <= (OTHERS => to_unsigned(16#00#, 8));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_4_1 = '1' THEN
        rd_data_downsample4_bypass_reg <= rd_data_overclock4;
      END IF;
    END IF;
  END PROCESS rd_data_downsample4_bypass_process;

  
  rd_data_1 <= rd_data_overclock4 WHEN enb_1_4_1 = '1' ELSE
      rd_data_downsample4_bypass_reg;

  row_RAM <= rd_data_1(3);

  p21outdata_mul_temp <= row_RAM * to_unsigned(16#2A8D#, 14);
  outdata_tmp <= p21outdata_mul_temp(21 DOWNTO 8);

  outdata <= std_logic_vector(outdata_tmp);

  ce_out <= enb_1_4_1;

END rtl;

