-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\USER\Desktop\Farneback_blockRAM\blockram_v2\codegen\PolyExp_pipeline1\hdlsrc\PolyExp_pipeline1_fixpt.vhd
-- Created: 2020-06-13 17:00:55
-- 
-- Generated by MATLAB 9.7, MATLAB Coder 4.3 and HDL Coder 3.15
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 0.5
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- outdata_src                   ce_out        1
-- outdata_0_0                   ce_out        1
-- outdata_0_1                   ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: PolyExp_pipeline1_fixpt
-- Source Path: PolyExp_pipeline1_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.PolyExp_pipeline1_fixpt_pkg.ALL;

ENTITY PolyExp_pipeline1_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        indata_src                        :   IN    std_logic_vector(7 DOWNTO 0);  -- ufix8
        indata_0_0                        :   IN    std_logic;  -- ufix1
        indata_0_1                        :   IN    std_logic;  -- ufix1
        ce_out                            :   OUT   std_logic;
        outdata_src                       :   OUT   std_logic_vector(21 DOWNTO 0);  -- ufix22_En15
        outdata_0_0                       :   OUT   std_logic_vector(7 DOWNTO 0);  -- ufix8
        outdata_0_1                       :   OUT   std_logic_vector(7 DOWNTO 0)  -- ufix8
        );
END PolyExp_pipeline1_fixpt;


ARCHITECTURE rtl OF PolyExp_pipeline1_fixpt IS

  -- Component Declarations
  COMPONENT PolyExp_pipeline1_fixpt_enb_bypass
    PORT( clk_1                           :   IN    std_logic;
          reset_1                         :   IN    std_logic;
          clk_enable_1                    :   IN    std_logic;
          clk_enable_2                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT PolyExp_pipeline1_fixpt_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_2_0                       :   OUT   std_logic;
          enb_1_2_1                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : PolyExp_pipeline1_fixpt_enb_bypass
    USE ENTITY work.PolyExp_pipeline1_fixpt_enb_bypass(rtl);

  FOR ALL : PolyExp_pipeline1_fixpt_tc
    USE ENTITY work.PolyExp_pipeline1_fixpt_tc(rtl);

  FOR ALL : SimpleDualPortRAM_generic
    USE ENTITY work.SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL enb_1_2_0                        : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_2_1                        : std_logic;
  SIGNAL clk_enable_1                     : std_logic;
  SIGNAL counterSig                       : std_logic;  -- ufix1
  SIGNAL indata_src_unsigned              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL bin_src                          : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL bin_0_0                          : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL bin_0_1                          : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL data_in                          : unsigned(23 DOWNTO 0);  -- ufix24
  SIGNAL BRAM_in                          : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL tmp                              : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL wr_data                          : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL wr_data_overclock2               : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL ratechange_splitcomp_out0        : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL ratechange_splitcomp_out1        : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL ctr                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ctr_1                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_1                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_2                            : std_logic;
  SIGNAL tmp_3                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL tmp_4                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL p14tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_5                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL wr_addr                          : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL wr_addr_overclock2               : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL ratechange_splitcomp_out0_1      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out1_1      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL wr_data_1                        : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL wr_addr_1                        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL rRam_ram_wr_en_k_0_sig           : std_logic;
  SIGNAL rRam_ram_wr_en_k_1_sig           : std_logic;
  SIGNAL rRam_ram_wr_en_sig               : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL rRam_ram_wr_en_sig_1             : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL rRam_ram_wr_en_sig_overclock2    : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL ratechange_splitcomp_out0_2      : std_logic;
  SIGNAL ratechange_splitcomp_out1_2      : std_logic;
  SIGNAL tmp_6                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL p16tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_7                            : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig_1            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL rd_addr                          : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL rd_addr_overclock2               : vector_of_unsigned8(0 TO 1);  -- ufix8 [2]
  SIGNAL ratechange_splitcomp_out0_3      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL ratechange_splitcomp_out1_3      : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL rRam_ram_wr_en_sig_2             : std_logic;
  SIGNAL rd_addr_1                        : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL rd_data                          : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL rd_data_signed                   : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL sel                              : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL sel_1                            : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL rRam_ram_demux_yreg              : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL rRam_ram_demux_yreg_next         : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL rRam_ram_demux_ctr1              : signed(31 DOWNTO 0);  -- int32
  SIGNAL rRam_ram_demux_ytmp              : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL rRam_ram_demux_add_cast          : signed(31 DOWNTO 0);  -- int32
  SIGNAL rd_data_overclock2               : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL rd_data_downsample2_bypass_reg   : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL rd_data_1                        : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL rRam                             : signed(23 DOWNTO 0);  -- sfix24
  SIGNAL y2                               : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL outdata_src_tmp                  : unsigned(21 DOWNTO 0);  -- ufix22_En15
  SIGNAL y1                               : unsigned(7 DOWNTO 0);  -- ufix8
  SIGNAL y0                               : unsigned(7 DOWNTO 0);  -- ufix8

BEGIN
  u_PolyExp_pipeline1_fixpt_enb_bypass : PolyExp_pipeline1_fixpt_enb_bypass
    PORT MAP( clk_1 => clk,
              reset_1 => reset,
              clk_enable_1 => clk_enable,
              clk_enable_2 => clk_enable_1
              );

  u_PolyExp_pipeline1_fixpt_tc : PolyExp_pipeline1_fixpt_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable_1,
              enb => enb,
              enb_1_2_0 => enb_1_2_0,
              enb_1_2_1 => enb_1_2_1
              );

  u_rRam_ram_generic : SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 8,
                 DataWidth => 24
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(wr_data_1),
              wr_addr => std_logic_vector(wr_addr_1),
              wr_en => rRam_ram_wr_en_sig_2,
              rd_addr => std_logic_vector(rd_addr_1),
              rd_dout => rd_data
              );

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  ctr_0_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      counterSig <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        counterSig <=  NOT counterSig;
      END IF;
    END IF;
  END PROCESS ctr_0_1_process;


  indata_src_unsigned <= unsigned(indata_src);

  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  --                                                                          %
  -- 
  --           Generated by MATLAB 9.7 and Fixed-Point Designer 6.4           %
  -- 
  --                                                                          %
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  ----------------------
  -- 
  ----------------------
  -- 
  ----------------------
  -- 
  -- DataTypeMode: Fixed-point: binary point scaling
  -- 
  -- Signedness: (1)Unsigned (0)signed
  -- 
  -- WordLength: 8
  -- 
  -- FractionLength: 0
  bin_src <= signed(indata_src_unsigned);

  bin_0_0 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & indata_0_0;

  bin_0_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & indata_0_1;

  data_in <= unsigned(bin_src) & unsigned(bin_0_0) & unsigned(bin_0_1);

  ---------------------- write BRAM
  BRAM_in <= signed(data_in);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_0 = '1' THEN
        tmp <= BRAM_in;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  wr_data(0) <= tmp;
  wr_data(1) <= tmp;

  wr_data_overclock2 <= wr_data;

  ratechange_splitcomp_out0 <= wr_data_overclock2(0);

  ratechange_splitcomp_out1 <= wr_data_overclock2(1);

  -- HDL code generation from MATLAB function: PolyExp_pipeline1_fixpt_trueregionp2
  ctr <= to_unsigned(16#01#, 8);

  -- HDL code generation from MATLAB function: PolyExp_pipeline1_fixpt_falseregionp2
  tmp_1 <= ctr_1 + to_unsigned(16#01#, 8);

  
  tmp_2 <= '1' WHEN ctr_1 = to_unsigned(16#C8#, 8) ELSE
      '0';

  
  tmp_3 <= tmp_1 WHEN tmp_2 = '0' ELSE
      ctr;

  ---------------------- read BRAM
  -- 
  -- HDL code generation from MATLAB function: PolyExp_pipeline1_fixpt
  -- 
  ---------------------- ctr counter
  ctr_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ctr_1 <= to_unsigned(16#01#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_0 = '1' THEN
        ctr_1 <= tmp_3;
      END IF;
    END IF;
  END PROCESS ctr_reg_process;


  p14tmp_sub_cast <= signed(resize(ctr_1, 32));
  tmp_4 <= p14tmp_sub_cast - 1;

  delayMatch_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp_5 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_0 = '1' THEN
        tmp_5 <= tmp_4;
      END IF;
    END IF;
  END PROCESS delayMatch_1_process;


  indexLogic_fixptsig <= unsigned(tmp_5(7 DOWNTO 0));

  wr_addr(0) <= indexLogic_fixptsig;
  wr_addr(1) <= indexLogic_fixptsig;

  wr_addr_overclock2 <= wr_addr;

  ratechange_splitcomp_out0_1 <= wr_addr_overclock2(0);

  ratechange_splitcomp_out1_1 <= wr_addr_overclock2(1);

  
  wr_data_1 <= ratechange_splitcomp_out0 WHEN counterSig = '0' ELSE
      ratechange_splitcomp_out1;

  
  wr_addr_1 <= ratechange_splitcomp_out0_1 WHEN counterSig = '0' ELSE
      ratechange_splitcomp_out1_1;

  rRam_ram_wr_en_k_0_sig <= '1';

  rRam_ram_wr_en_k_1_sig <= '0';

  rRam_ram_wr_en_sig(0) <= rRam_ram_wr_en_k_0_sig;
  rRam_ram_wr_en_sig(1) <= rRam_ram_wr_en_k_1_sig;

  rRam_ram_wren_match_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rRam_ram_wr_en_sig_1 <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_0 = '1' THEN
        rRam_ram_wr_en_sig_1 <= rRam_ram_wr_en_sig;
      END IF;
    END IF;
  END PROCESS rRam_ram_wren_match_process;


  rRam_ram_wr_en_sig_overclock2 <= rRam_ram_wr_en_sig_1;

  ratechange_splitcomp_out0_2 <= rRam_ram_wr_en_sig_overclock2(0);

  ratechange_splitcomp_out1_2 <= rRam_ram_wr_en_sig_overclock2(1);

  p16tmp_sub_cast <= signed(resize(ctr_1, 32));
  tmp_6 <= p16tmp_sub_cast - 1;

  delayMatch_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp_7 <= to_signed(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_0 = '1' THEN
        tmp_7 <= tmp_6;
      END IF;
    END IF;
  END PROCESS delayMatch_2_process;


  indexLogic_fixptsig_1 <= unsigned(tmp_7(7 DOWNTO 0));

  rd_addr(0) <= indexLogic_fixptsig_1;
  rd_addr(1) <= indexLogic_fixptsig_1;

  rd_addr_overclock2 <= rd_addr;

  ratechange_splitcomp_out0_3 <= rd_addr_overclock2(0);

  ratechange_splitcomp_out1_3 <= rd_addr_overclock2(1);

  
  rRam_ram_wr_en_sig_2 <= ratechange_splitcomp_out0_2 WHEN counterSig = '0' ELSE
      ratechange_splitcomp_out1_2;

  
  rd_addr_1 <= ratechange_splitcomp_out0_3 WHEN counterSig = '0' ELSE
      ratechange_splitcomp_out1_3;

  rd_data_signed <= signed(rd_data);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  c_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sel <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF sel >= to_unsigned(16#01#, 8) THEN 
          sel <= to_unsigned(16#00#, 8);
        ELSE 
          sel <= sel + to_unsigned(16#01#, 8);
        END IF;
      END IF;
    END IF;
  END PROCESS c_process;


  delayMatch_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      sel_1 <= to_unsigned(16#00#, 8);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        sel_1 <= sel;
      END IF;
    END IF;
  END PROCESS delayMatch_3_process;


  rRam_ram_demux_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rRam_ram_demux_yreg <= (OTHERS => to_signed(16#000000#, 24));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        rRam_ram_demux_yreg <= rRam_ram_demux_yreg_next;
      END IF;
    END IF;
  END PROCESS rRam_ram_demux_process;

  rRam_ram_demux_add_cast <= signed(resize(sel_1, 32));
  rRam_ram_demux_ctr1 <= rRam_ram_demux_add_cast + 1;
  
  rRam_ram_demux_ytmp(0) <= rd_data_signed WHEN rRam_ram_demux_ctr1 = to_signed(16#00000001#, 32) ELSE
      rRam_ram_demux_yreg(0);
  
  rRam_ram_demux_ytmp(1) <= rd_data_signed WHEN rRam_ram_demux_ctr1 = to_signed(16#00000002#, 32) ELSE
      rRam_ram_demux_yreg(1);
  rRam_ram_demux_yreg_next(0) <= rRam_ram_demux_ytmp(0);
  rd_data_overclock2(0) <= rRam_ram_demux_ytmp(0);
  rRam_ram_demux_yreg_next(1) <= rRam_ram_demux_ytmp(1);
  rd_data_overclock2(1) <= rRam_ram_demux_ytmp(1);

  rd_data_downsample2_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      rd_data_downsample2_bypass_reg <= (OTHERS => to_signed(16#000000#, 24));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_2_1 = '1' THEN
        rd_data_downsample2_bypass_reg <= rd_data_overclock2;
      END IF;
    END IF;
  END PROCESS rd_data_downsample2_bypass_process;

  
  rd_data_1 <= rd_data_overclock2 WHEN enb_1_2_1 = '1' ELSE
      rd_data_downsample2_bypass_reg;

  ---------------------- operator
  rRam <= rd_data_1(1);

  y2 <= unsigned(rRam(23 DOWNTO 16));

  outdata_src_tmp <= y2 * to_unsigned(16#2A8D#, 14);

  outdata_src <= std_logic_vector(outdata_src_tmp);

  y1 <= unsigned(rRam(15 DOWNTO 8));

  outdata_0_0 <= std_logic_vector(y1);

  y0 <= unsigned(rRam(7 DOWNTO 0));

  outdata_0_1 <= std_logic_vector(y0);

  ce_out <= enb_1_2_1;

END rtl;

